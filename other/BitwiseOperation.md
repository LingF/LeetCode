## 位运算

### 概念

十进制：逢十进一

```
208 = 2 * 100 + 0 * 10 + 8 * 0
    = 2 * 10^2 + 0 * 10^1 + 8 * 10^0
```

二进制：逢二进一

```
208 = 1 * 128 + 1 * 64 + 0 * 32 + 1 * 16 + 0 * 8 + 0 * 4 + 0 * 2 + 0 * 1
    = 1 * 2^7 + 1 * 2^6 + 0 * 2^5 + 1 * 2^4 + 0 * 2^3 + 0 * 2^2  + 0 * 2^1 + 0 * 2^0
    = 11010000  
```

单位：8位 = 1字节

#### 负数

考虑：-1 的补码为什么全是1？

正数的原码、反码、补码在计算机中都一致。

计算机中负数的表示，是以 __补码__ 的形式呈现的：

- 原码：

  ```
  00000000 00000000 00000000 00000101 是  5 的原码
  10000000 00000000 00000000 00000101 是 -5 的原码
  ```

  > 最高位：符号位

- 反码：

  ```
  00000000 00000000 00000000 00000101 是  5 的反码
  11111111 11111111 11111111 11111010 是 -5 的反码
  ```

  > 对负数的原码除了符号位，全部取反，则得到该负数的反码

- 补码：

  ```
  00000000 00000000 00000000 00000101 是  5 的补码
  11111111 11111111 11111111 11111011 是 -5 的补码
  ```

  > 该负数反码的基础上 + 1

所以可以解释-1 的补码全是1：

```
  1 = 0000...0001
 -1 = 1000...0001
反码：1111...1110
补码：1111...1111 
```

### 常用位运算

每一位单独做运算

- 按位与 `&`（`1 & 1 = 1` `0 & 0 = 0` `1 & 0 = 0`）
- 按位或 `|`（`1 | 1 = 1` `0 | 0 = 0` `1 | 0 = 1`）
- 按位非 `~`（`~1 = 0` `~0 = 1`）
- 按位异或 `^`（`1 ^ 1 = 0` `0 ^ 0 = 0` `1 ^ 0 = 1`）
    - 一样的两个异或则是 0
    - 不一样则是 1
- 有符号右移 `>>`
    - 正数：高位补 0
    - 负数：高位补 1
- 有符号左移 `<<`
- 无符号右移 `>>>`（不论正负，高位均补 0）

```javascript
var value = parseInt(-4).toString(2) // '-100'

~value // 99
value>>1 // -50
value<<1 // -200
value>>>1 // 2147483598
```

### 运用场景和优劣势

#### 场景

1. 网络通信
2. hash map
3. 商品属性
    - 一个 int 类型 32 位，每一位可以存储一个属性（只有两种状态的属性）；比几十个字段存储属性节省很多存储空间
4. 权限控制（有或没有）
5. 简单的可逆加密（用异或）
    - `1 ^ 1 ^ 1 = 1`：明文 ^ n = 密文；密文 ^ n = 明文

#### 优劣势

优：

- 节省代码量
- 节约空间
- 运行效率高

劣：

- 不直观

> 日常中是否使用，通过可维护性、性能等方面的全面考虑


### 常见问题

- 取模
    - `x % 2^n` → `x & (2^n - 1)` 更高效
- 判断奇偶数（偶数：`x % 2 = 0`；奇数：`x % 2 = 1`）
    - `4 = 100; 5 = 101; 6 = 110; 7 = 111`
      得到：偶数 _最后位 0_；奇数 _最后位 1_
      所以：__`x & 1 = 0` 为偶数；`x & 1 = 1` 为奇数__
- 实现数字翻倍或减半
    - 左移翻倍
    - 右移减半 arraylist 扩容每次1.5倍 (n + n >> 1 = 1.5n)
- 交换两数（不借助临时变量 `a = a + b; b = a - b; a = a - b`）
    - 利用位运算：
      ```javascript
      a = a ^ b
      b = a ^ b // b = (a ^ b) ^ b = a ^ (b ^ b) = a
      a = a ^ b // a = (a ^ b) ^ a = (a ^ a) ^ b = b
      ```
