## 树

1. 根结点唯一
2. 子树个数没有限制，但一定互不相交

### 相关概念

- 结点的度
   + 分支结点（度非0）
   + 终端结点（度为0）
- 树的度：树中结点度的最大值
- 结点间的关系
   + 根结点
   + 双亲结点（parent）
   + 兄弟结点（sibling）
   + 祖先结点 | 子孙结点
- 树的深度（高度 | 最大层次）：根（1）... n（n + 1）

### 树的存储

![例子](https://s3.bmp.ovh/imgs/2022/04/27/7b0dfd4f4f914849.png)

- 双亲表示法（孩子指向双亲，根结点没有双亲-1填充）
  + 缺点：找孩子必须遍历整个表
    编号 | data | parent
    - | - | -
    0 | A | -1
    1 | B | 0
    2 | C | 0
    3 | D | 1
    4 | E | 2
    5 | F | 2
    6 | G | 3
    7 | H | 3
    8 | I | 3
    9 | J | 4
- 孩子表示法（双亲结点指向孩子）
  + [data][child1][...][childn]
    - 孩子域个数由树的度决定，所有结点都有n个用来存放孩子
    - 缺点：当度相差比较大时，比较浪费空间
  + [data]__[degree]__[child1][...][childn]
    - 多一个 degree 表示当前结点的度，对应几个孩子域
    - 缺点：计算时间损耗，处理结点时代码不容易统一
- 孩子兄弟表示法
  + 混合结构
    ![孩子兄弟表示法](https://s3.bmp.ovh/imgs/2022/04/27/2adaae7ced404a3f.png)
    - 结点放在顺序存储的数组（编号）
    - 每个结点的孩子用单链表
      > 1. 遍历整棵树：循环数组
      > 2. 某个结点的孩子：找到对应结点，顺着链表找
      > 3. 如何找某个结点的双亲（这个结构就不友好了）:需要遍历整棵树，检测每个结点下面的孩子结点包不包括自己
  + 在数组中结合双亲表示法：添加 parent
  + 兄弟的角度：[data][firstchild][rightsib]

