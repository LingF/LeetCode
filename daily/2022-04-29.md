## 每日一题 - 二叉树的前序遍历

### 信息卡片

- 时间：2022-04-29
- 题目链接：<https://leetcode.com/problems/binary-tree-preorder-traversal/>
- tag：`栈` `树` `深度优先搜索` `二叉树`

### 题目描述

给你二叉树的根节点 `root` ，返回它节点值的 __前序__ 遍历。

__示例1：__

![1](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

__示例2：__

```
输入：root = []
输出：[]
```

__示例3：__

```
输入：root = [1]
输出：[1]
```

__示例4：__

![4](https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg)

```
输入：root = [1,2]
输出：[1,2]
```

__示例5：__

![](https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg)

```
输入：root = [1,2]
输出：[1,2]
```

__提示：__

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

### 思路分析

1. 递归

### 参考答案

#### 1. 递归 $O(n)$

空间复杂度：$O(n)$

```javascript {.line-numbers}
function preorderTraversal(root) {
  let res = []
  if (!root) return []
  // 前序遍历
  // 当前根结点
  res.push(root.val)
  // 左子树
  res = [
    ...res,
    ...inorderTraversal(root.left)
  ]
  // 右子树
  res = [
    ...res,
    ...inorderTraversal(root.right)
  ]
  return res
}
```

#### 2. 循环遍历 $O(n)$

空间复杂度：$O(n)$

```javascript {.line-numbers}
function inorderTraversal(root) {
  let res = []
  let stack = []

  // 栈不为空 或者 当前结点存在
  while(root || stack.length) {
    while(root) {
      // [前序遍历]
      // 值放入结果中
      res.push(root.val)
      // 当前根结点不为空，压入栈
      stack.push(root)
      // 访问当前根结点左子树
      root = root.left
    }
    // ↑循环完后：最左边叶子结点在栈顶（第一次）

    // 弹出栈顶结点
    root = stack.pop()
    // 访问弹出结点的右子树
    // 如果没有：root = null（用于 while 循环判断）
    root = root.right
  }
  return res
}
```

#### 3. Morris 遍历（待补充）

核心思想是利用树的大量空闲指针，实现空间开销的极限缩减
